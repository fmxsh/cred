#!/bin/bash

# TODO: V to view single key in less

# Set to "" or "micro" or "default" to use the default editor micro
# USE_NVIM="default"
USE_EDITOR="nvim"

# Function to calculate and print a concise size summary of kv_store with dynamic units
calculate_kv_store_summary() {
	local total_size=0
	local total_entries=0

	# Iterate through kv_store to calculate total size and entry count
	for key in "${!kv_store[@]}"; do
		if ignore_this_key "$key"; then
			continue
		fi
		total_size=$((total_size + ${#key} + ${#kv_store[$key]}))
		total_entries=$((total_entries + 1))
	done

	# Convert total size to a human-readable format
	# TODO: Not sure this gets it right, size, or does it?
	human_readable_size() {
		local size=$1
		if ((size < 1024)); then
			echo "${size} B"
		elif ((size < 1048576)); then
			echo "$(bc <<<"scale=2; $size/1024") KB"
		elif ((size < 1073741824)); then
			echo "$(bc <<<"scale=2; $size/1048576") MB"
		else
			echo "$(bc <<<"scale=2; $size/1073741824") GB"
		fi
	}

	# Get human-readable size
	readable_size=$(human_readable_size $total_size)

	# Print concise output
	echo "(entries: $total_entries, size: $readable_size)"
}

allow_edit() {
	local data_file="$1"
	local data_file_is_remote="$2"
	if [[ $data_file_is_remote -eq 1 ]]; then
		# If we passed allow_edit and have come here, the __write must exist
		if key_exists_in_kv_store "__write"; then
			return 0 # True: Editing allowed
		else
			return 1 # False: Editing not allowed
		fi
	fi

	# Local file, editing allowed
	return 0 # True: Editing allowed
}

key_exists_in_kv_store() {
	local key="$1"
	if [[ -n "${kv_store[$key]}" ]]; then
		return 0 # True: Key exists
	else
		return 1 # False: Key does not exist
	fi
}
print_confirmation() {
	local text="$1"
	echo -ne "$text"
}

confirm_exit() {
	if [[ $unsaved_changes -eq 1 ]]; then

		echo -e "\n\e[93mExiting without saving (changes existed)...\e[0m"
		exit 1
	else
		echo -e "\e[92mExiting (no changes had been made)...\e[0m"
		exit 0
	fi

}
confirm_exit_wrap() {
	# add a newline after the ^C
	echo "^C"
	confirm_exit
	stty sane # Reset terminal state to ensure proper input handling
}
# Set the trap for SIGINT (CTRL+C)
trap "confirm_exit_wrap" SIGINT

# Encrypt data function
encrypt_data() {
	local data="$1"
	local password="$2"
	local iterations="$3"
	if command -v gum >/dev/null 2>&1; then
		# Use gum if installed
		gum spin --spinner "line" --title 'Encrypting data...' -- sh -c "echo -n \"$data\" | openssl enc -aes-256-cbc -pbkdf2 -iter \"$iterations\" -salt -pass pass:\"$password\" | base64 -w 0"
		#gum spin --spinner "line" --title 'Encrypting data...' -- \
		#	echo -n "$data" | openssl enc -aes-256-cbc -pbkdf2 -iter "$iterations" -salt -pass pass:"$password" | base64 -w 0

	else
		#	echo -n "$data" | openssl enc -aes-256-gcm -pbkdf2 -iter "$iterations" -salt -pass pass:"$password" | base64 -w 0

		echo -n "$data" | openssl enc -aes-256-cbc -pbkdf2 -iter "$iterations" -salt -pass pass:"$password" | base64 -w 0
	fi
}

# Decrypt data function
decrypt_data() {
	local data="$1"
	local password="$2"
	local iterations="$3"

	# NOTE: Why is used in the command? 2>&1 and shouodht it have been /dev/null?
	# NOTE: Would get base64: invalid input, for no good reason
	# NOTE: Because of a bug (?)
	# NOTE: Now it is gone
	if command -v gum >/dev/null 2>&1; then
		# Use gum if installed
		gum spin --spinner "line" --title 'Decrypting data...' -- sh -c "echo -n \"$data\" | base64 -d | openssl enc -d -aes-256-cbc -pbkdf2 -iter \"$iterations\" -pass pass:\"$password\" "

		#		echo -n "$data" | base64 -d | openssl enc -d -aes-256-cbc -pbkdf2 -iter "$iterations" -pass pass:"$password"
		#gum spin --spinner "line" --title 'Decrypting data...' -- \
		#	echo -n "$data" | base64 -d | openssl enc -d -aes-256-cbc -pbkdf2 -iter "$iterations" -pass pass:"$password"
	else

		echo -n "$data" | base64 -d | openssl enc -d -aes-256-cbc -pbkdf2 -iter "$iterations" -pass pass:"$password"
	fi
}

is_remote_file() {
	local file="$1"
	[[ "$file" =~ ^https?:// ]]
}

# Generate metadata for the vault file
generate_metadata() {
	local encrypted_data="$1"
	local iterations="$2"
	local decryption_function_in_base64="$3"
	local timestamp
	timestamp=$(date +"%Y-%m-%d %H:%M:%S")

	echo "number-of-iterations"
	echo "$iterations"
	echo "last-modified"
	echo "$timestamp"
	if [[ -n "$4" ]]; then
		echo "custom-crypto-version"
		echo "$4"
	fi
	echo "encrypted-data"
	echo "$encrypted_data"
	echo "decryption-function"
	echo "$decryption_function_in_base64"
	# Include custom-crypto-version if provided
}

parse_metadata() {
	local file="$1"
	declare -A metadata
	local key value

	# Check if the file is a URL (starts with http:// or https://)
	if [[ "$file" =~ ^https?:// ]]; then
		# Fetch the content using curl
		content=$(curl -fSL "$file")
		if [[ $? -ne 0 ]]; then
			echo "Error: Unable to fetch metadata from URL: $file"
			exit 1
		fi
	else
		# Read the local file content
		content=$(cat "$file")
	fi

	# Parse the content line by line, alternating between key and value
	while read -r key && read -r value; do
		metadata["$key"]="$value"
	done <<<"$content"

	# Print the metadata array for debugging
	echo "$(declare -p metadata)"
}

# Extract key(s) function
extract_keys() {
	local keys="$1"
	local missing_keys=()
	local found=0

	for key in $keys; do
		if [[ -n "${kv_store[$key]}" ]]; then
			echo "${kv_store[$key]}"
			found=1
		else
			missing_keys+=("$key")
		fi
	done

	# Report missing keys if any
	if [[ ${#missing_keys[@]} -gt 0 ]]; then
		echo "Missing keys: ${missing_keys[*]}"
	fi

	# Exit with an error if no keys were found
	if [[ $found -eq 0 ]]; then
		echo "Error: No keys found."
		exit 1
	fi
}

# calculate_decryption_time_for_given_iter() {
# 	local given_iter=$1
# 	local test_iter=100000 # Fixed test iteration count for optimal balance
#
# 	# Ensure input is valid
# 	if [[ ! "$given_iter" =~ ^[0-9]+$ ]] || [[ "$given_iter" -le 0 ]]; then
# 		echo "Invalid input. Please provide a valid positive number for iterations."
# 		exit 1
# 	fi
#
# 	# Perform test
# 	start_time=$(date +%s.%N)
# 	echo -n "test-data" | openssl enc -aes-256-cbc -pbkdf2 -iter $test_iter -salt -pass pass:"testpassword" >/dev/null 2>&1
# 	end_time=$(date +%s.%N)
#
# 	# Calculate elapsed time for the test
# 	elapsed_time=$(echo "$end_time - $start_time" | bc)
#
# 	# Extrapolate the time for the given number of iterations
# 	estimated_time=$(echo "$elapsed_time * $given_iter / $test_iter" | bc -l)
#
# 	# Convert estimated time to minutes and seconds
# 	minutes=$(echo "$estimated_time / 60" | bc)
# 	seconds=$(echo "$estimated_time % 60" | bc | sed 's/^\./0./' | cut -d. -f1)
#
# 	# Return the compact result
# 	#echo "This iter takes roughly: ${minutes}m ${seconds}s on this system."
# 	echo -e "This iter takes roughly: \e[40;91m ${minutes}m \e[0m \e[40;91m ${seconds}s \e[0m on this system."
#
# }

calculate_decryption_time_for_given_iter() {
	local given_iter=$1

	# Validate input
	if [[ ! "$given_iter" =~ ^[0-9]+$ ]] || [[ "$given_iter" -le 0 ]]; then
		echo "Invalid input. Please provide a valid positive number for iterations."
		exit 1
	fi

	# Define test parameters
	local test_iter=1
	local elapsed_time=0
	local test_data="test-data"
	local test_password="testpassword"
	local encrypted_test_data=""
	local has_custom_func=0

	if [[ -n "${kv_store["__ced"]}" ]]; then

		# Evaluate the function definition
		eval "${kv_store["__ced"]}"
		if declare -f custom_encrypt_data >/dev/null; then
			echo "(Using custom_encrypt_data function for testing.)"
			has_custom_func=1
		else
			echo "__ced found but custom_encrypt_data function not found."
			return 1
		fi
	else
		echo "(Using default encryption for testing.)"

	fi
	# Find a suitable test_iter that takes ~1 second
	while (($(echo "$elapsed_time < 1" | bc -l))); do
		start_time=$(date +%s.%N)

		# Check if the function exists before calling it
		if [[ $has_custom_func -eq 1 ]]; then
			encrypted_test_data=$(custom_encrypt_data "$combined_data" "$password" "$test_iter")

		else
			# Fallback to standard encryption
			echo -n "$test_data" | openssl enc -aes-256-cbc -pbkdf2 -iter $test_iter -salt -pass pass:"$test_password" >/dev/null 2>&1
		fi

		end_time=$(date +%s.%N)
		elapsed_time=$(echo "$end_time - $start_time" | bc -l)

		# Double the test_iter for the next iteration if elapsed_time < 1 second
		if (($(echo "$elapsed_time < 1" | bc -l))); then
			test_iter=$((test_iter * 2))
		fi
	done

	#echo "Found suitable test_iter: $test_iter (Elapsed Time: ${elapsed_time}s)"

	# Extrapolate the time for the given_iter
	estimated_time=$(echo "$elapsed_time * $given_iter / $test_iter" | bc -l)

	# Convert estimated time to minutes and seconds
	minutes=$(echo "$estimated_time / 60" | bc)
	seconds=$(echo "$estimated_time % 60" | bc | sed 's/^\./0./' | cut -d. -f1)

	# Display the results
	echo -e "Decryption with $given_iter iterations takes roughly: \e[40;91m ${minutes}m \e[0m \e[40;91m ${seconds}s \e[0m on this system."
}

generate_password() {
	local length="$1"
	local password

	# Generate the password using /dev/urandom and tr to filter allowed characters
	password=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9!@#$%^&*()-_=+<>?,.:;~`[]{}|/' | head -c "$length")

	# Ensure the password is exactly the desired length
	while [[ ${#password} -lt $length ]]; do
		password+=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9!@#$%^&*()-_=+<>?,.' | head -c $((length - ${#password})))
	done

	echo "$password"
}

# Add this function for executing and evaluating the content of a key
execute_key() {
	local key="$1"
	if [[ -z "$key" ]]; then
		echo "Error: No key provided for execution."
		return 1
	fi

	# Check if the key exists in the kv_store
	if [[ -n "${kv_store[$key]}" ]]; then
		local script="${kv_store[$key]}"
		# Replace metasyntax {{key_name}} with corresponding kv_store values
		while [[ "$script" =~ \{\{([a-zA-Z0-9:._-]+)\}\} ]]; do
			local placeholder="${BASH_REMATCH[0]}"
			local key_name="${BASH_REMATCH[1]}"

			# Get the value of the referenced key
			local value="${kv_store[$key_name]}"
			if [[ -z "$value" ]]; then
				# the placeholder doesn't exist as key in kv_store, but may in opt_store below
				local value="${opt_store[$key_name]}"
				if [[ -z "$value" ]]; then
					echo "Error: Key '$key_name' found neither in kv_store nor opt_store for placeholder $placeholder."
					return 1
				fi
			fi

			# Replace the placeholder in the script
			script="${script//$placeholder/$value}"
		done

		# Export so we can use vault_[key}
		for key in "${!kv_store[@]}"; do
			if ignore_this_key "$key"; then
				continue
			fi

			# Prefix each key with "vault_" for exporting
			export_name="vault_${key}"

			# Export the key's value safely
			export "$export_name=${kv_store[$key]}"

		done

		# NOTE: For consistency, __write should be accessible here too
		# NOTE: __write key doesnt hold a function anyway, perhaps it should for consistency
		# Make sure we can access the custom encryption functions
		if [[ -n "${kv_store["__ced"]}" ]]; then
			# Evaluate the function definition
			eval "${kv_store["__ced"]}"
		fi
		if [[ -n "${kv_store["__ced"]}" ]]; then
			# Evaluate the function definition
			eval "${kv_store["__cdd"]}"
		fi

		# Execute the final script
		#echo "Executing content of key: $key"
		eval "$script"
		local exit_status=$?

		# Synchronize back any updated environment variables
		# That is, the script can update values in the vault
		for key in "${!kv_store[@]}"; do
			export_name="vault_${key}"
			if [[ -n "${!export_name}" && "${!export_name}" != "${kv_store[$key]}" ]]; then
				# Update kv_store with the new value
				kv_store[$key]="${!export_name}"
				#echo "Updated kv_store[$key] with new value from $export_name."
				# Length of new value

				bytes_written=${#kv_store[$key]}
				write_global_history "$key" "updated by 'eval $script'"
				unsaved_changes=1
			fi
		done

		# Unset previously exported variables
		for key in "${!kv_store[@]}"; do
			if ignore_this_key "$key"; then
				continue
			fi

			# Prefix each key with "vault_" for unsetting
			export_name="vault_${key}"

			# Unset the key's exported value
			unset "$export_name"
			# NOTE: Zeroing out the value is not guaranteed to be beneficial
		done

		return "$exit_status"
	else
		echo "Error: Key '$key' does not exist."
		return 1
	fi
}
# Function to print the script key with its index and comments
print_script_with_comments() {
	local index="$1"
	local key="$2"

	# Validate the key is non-empty and exists in kv_store
	if [[ -n "$key" && -v kv_store[$key] ]]; then
		local script_content="${kv_store[$key]}"

		# Extract the first comment line after #!/bin/bash
		local comment_line
		comment_line=$(echo "$script_content" | awk '/^#!/ {in_comment=1; next} in_comment && /^# / {print; exit}')

		# Print the key with its index and additional comment if available
		if [[ -n "$comment_line" ]]; then
			echo -e " \e[36m[\e[96m$index\e[36m]\e[0m $key \e[36m$comment_line\e[0m"
		else
			echo -e " \e[36m[\e[96m$index\e[36m]\e[0m $key"
		fi
	else
		echo -e "\e[91mError: Invalid or missing key '$key'.\e[0m"
	fi
}
print_help_key() {
	echo -ne $' \e[35m(\e[0m\e[97ms\e[0m\e[35m)\e[0m set key\n'
	echo -ne $' \e[35m(\e[0m\e[97mu\e[0m\e[35m)\e[0m unset key\n'
	echo -ne $' \e[35m(\e[0m\e[97me\e[0m\e[35m)\e[0m edit key\'s value\n'
	echo -ne $' \e[35m(\e[0m\e[97ma\e[0m\e[35m)\e[0m absorb file into key\'s\n'
	echo -ne $' \e[35m(\e[0m\e[97mr\e[0m\e[35m)\e[0m rename key\n'
	echo -ne $' \e[35m(\e[0m\e[97my\e[0m\e[35m)\e[0m yank key to clipboard\n'
	echo -ne $' \e[35m(\e[0m\e[97mg\e[0m\e[35m)\e[0m generate password for key\n'
	echo -ne $' \e[35m(\e[0m\e[97mx\e[0m\e[35m)\e[0m execute key as bash script\n'
	echo -ne $' \e[35m(\e[0m\e[97mb\e[0m\e[35m)\e[0m toggle base64 encode/decode\n'
	echo -ne $' \e[35m(\e[0m\e[97mh\e[0m\e[35m)\e[0m view history for key\n'
	echo -ne $' \e[35m(\e[0m\e[97mV\e[0m\e[35m)\e[0m view content of key\n'
}
print_help() {
	echo -ne $'             Commands to manage vault\n'
	echo -ne $'\e[90m──────────────────── Key ops   ─────────────────\e[0m\n'
	print_help_key
	echo -ne $'\e[90m──────────────────── Keys ops  ─────────────────\e[0m\n'
	echo -ne $' \e[35m(\e[0m\e[97mv\e[0m\e[35m)\e[0m view keys\n'
	echo -ne $' \e[35m(\e[0m\e[97mH\e[0m\e[35m)\e[0m view keys having history\n'
	echo -ne $' \e[35m(\e[0m\e[97mX\e[0m\e[35m)\e[0m list bash scripts and exeucte\n'
	echo -ne $'\e[90m──────────────────── Vault     ─────────────────\e[0m\n'
	echo -ne $' \e[35m(\e[0m\e[97mG\e[0m\e[35m)\e[0m view global vault history\n'
	echo -ne $' \e[35m(\e[0m\e[97mi\e[0m\e[35m)\e[0m iterations ['"$iterations"'] change\n'
	echo -ne $' \e[35m(\e[0m\e[97mp\e[0m\e[35m)\e[0m password change\n'
	echo -ne $' \e[35m(\e[0m\e[97mw\e[0m\e[35m)\e[0m write vault to disk\n'
	echo -ne $' \e[35m(\e[0m\e[97m:\e[0m\e[35m)\e[0m command mode\n'
	echo -ne $' \e[35m(\e[0m\e[97mt\e[0m\e[35m)\e[0m test custom crypto functions\n'
	echo -ne $'\e[90m──────────────────── Interface ──────────────────\e[0m\n'
	echo -ne $' \e[35m(\e[0m\e[97mm\e[0m\e[35m)\e[0m selecte marked key (enter key-marking mode)\n'
	echo -ne $' \e[35m(\e[0m\e[97mM\e[0m\e[35m)\e[0m toggle key-marking mode\n'
	echo -ne $' \e[35m(\e[0m\e[97mn\e[0m\e[35m)\e[0m cycle previous/current marked key\n'
	echo -ne $' \e[35m(\e[0m\e[97mm\e[0m\e[35m)\e[0m exit key-marking mode\n'
	echo -ne $' \e[35m(\e[0m\e[97m?\e[0m\e[35m)\e[0m help\n'
	echo -ne $' \e[35m(\e[0m\e[97mI\e[0m\e[35m)\e[0m additional info\n'
	echo -ne $' \e[35m(\e[0m\e[97mq\e[0m\e[35m)\e[0m quit\n'
	echo -ne $'\e[90m─────────────────────────────────────────────────\e[0m\n'

}
# Function to get keys matching a specific condition
get_matching_keys() {
	local -n result_array=$1 # Pass an array by reference to store matching keys
	local condition=$2       # Condition to filter keys (e.g., regex pattern)

	result_array=() # Initialize or clear the result array

	# Loop through kv_store and filter keys based on the condition
	for key in "${!kv_store[@]}"; do
		if [[ -n "$key" && "${kv_store[$key]}" =~ $condition ]]; then
			result_array+=("$key")
		fi
	done
}

# Function to mark a key using dialog
mark_mode() {
	local -a menu_options
	local selected_key

	# Check if fzf is installed
	if command -v fzf >/dev/null 2>&1; then
		# Define colors (ANSI escape codes)
		local key_color_normal="\e[93m"  # Bright Yellow for normal keys
		local key_color_special="\e[37m" # White for keys with "__"
		local desc_color="\e[90m"        # Gray for descriptions
		local reset_color="\e[0m"

		# Calculate the maximum key length for alignment
		local max_key_length=0
		for key in "${!kv_store[@]}"; do
			[[ ${#key} -gt $max_key_length ]] && max_key_length=${#key}
		done

		# Sort keys alphabetically
		mapfile -t sorted_keys < <(printf '%s\n' "${!kv_store[@]}" | sort)

		# Populate menu options with aligned and colored columns
		for key in "${sorted_keys[@]}"; do
			if ignore_this_key "$key"; then
				continue
			fi

			# Extract the first 40 characters of the key's value, removing newlines
			local description=$(echo -n "${kv_store[$key]}" | tr -d '\n' | cut -c1-40)

			# Align the key by padding with spaces
			local padded_key=$(printf "%-${max_key_length}s" "$key")

			# Apply color based on key pattern
			if [[ "$key" == *__* ]]; then
				# Keys with "__" -> White
				menu_options+=("$(echo -e "${key_color_special}${padded_key}${reset_color}"$'\t'"${desc_color}${description}${reset_color}")")
			else
				# Other keys -> Bright Yellow
				menu_options+=("$(echo -e "${key_color_normal}${padded_key}${reset_color}"$'\t'"${desc_color}${description}${reset_color}")")
			fi
		done

		# Use fzf to display aligned and colored columns
		selected_key=$(printf '%s\n' "${menu_options[@]}" |
			fzf --prompt="Select a key to mark: " \
				--ansi \
				--delimiter=$'\t' \
				--with-nth=1,2 \
				--nth=1 \
				--no-sort \
				--exact |
			sed -E "s/\x1b\[[0-9;]*m//g" | cut -f1 | xargs) # Remove ANSI color codes and trailing whitespace
		echo -n "$selected_key"
	else
		# Fallback to dialog if fzf is not installed

		# Get terminal dimensions
		local term_height=$(tput lines)
		local term_width=$(tput cols)

		# Sort keys alphabetically
		mapfile -t sorted_keys < <(printf '%s\n' "${!kv_store[@]}" | sort)

		# Populate menu options for dialog
		for key in "${sorted_keys[@]}"; do
			if ignore_this_key "$key"; then
				continue
			fi

			# Extract the first 40 characters of the key's value, removing newlines
			local description=$(echo -n "${kv_store[$key]}" | tr -d '\n' | cut -c1-40)
			menu_options+=("$key" "$description")
		done

		# Use dialog to display the menu in full screen
		selected_key=$(dialog --title "Mark Mode" \
			--menu "Select a key to mark:" "$term_height" "$term_width" 15 \
			"${menu_options[@]}" 2>&1 >/dev/tty)
	fi

}

# Function to add a history entry for a key
add_history_entry() {
	local key="$1"
	local data="${2:-${kv_store[$key]}}" # Use provided data or default to kv_store value

	# Ensure the key exists in kv_store if data is not explicitly provided
	if [[ -z "$key" || (-z "$2" && ! -v kv_store["$key"]) ]]; then
		echo -e "\e[91mError: Key '$key' does not exist in kv_store, and no data was provided.\e[0m"
		return 1
	fi

	# Get the current count of history entries for this key
	local history_count_key="__hst_0_${key}"
	local count=0
	if [[ -v kv_store["$history_count_key"] ]]; then
		count="${kv_store["$history_count_key"]}"
	fi

	# Increment the counter
	count=$((count + 1))

	# Format the date in ISO 8601 format
	local timestamp
	timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

	# Create the new history key
	local history_key="__hst_${count}_${key}"

	# Prepend the timestamp to the provided or existing value and store it in the new history key
	kv_store["$history_key"]="${timestamp} ${data}"

	# Update the count in the special key
	kv_store["$history_count_key"]="$count"

	#echo -e "\e[92mHistory entry added: $history_key\e[0m"
}

# Function to list all history entries for a given key
# Function to list all history entries for a given key
list_history_entries() {
	local key="$1"

	# Check if there are any history keys for the provided key
	local found_history=false

	echo -e "\e[96mHistory entries for key: $key\e[0m"
	for history_key in "${!kv_store[@]}"; do
		# Skip if the key does not match the pattern for this key's history
		if [[ "$history_key" == "__hst_0_${key}" ]]; then
			continue
		fi

		if [[ "$history_key" == __hst_*_${key} ]]; then
			found_history=true
			local full_content="${kv_store["$history_key"]}"
			local timestamp="${full_content%% *}" # Extract timestamp (first content before space)
			local remaining="${full_content#* }"  # Extract the rest of the content

			# Print the key name in bright blue
			echo -en "\e[93m$history_key:\e[0m "

			# Print the timestamp in bright yellow
			echo -en "\e[95m$timestamp\e[0m "

			# Print the remaining content in default text color
			echo -e "$remaining"
		fi
	done

	# If no history entries were found
	if [[ "$found_history" == false ]]; then
		echo -e "\e[93mNo history entries found for key: $key\e[0m"
		return 1
	fi
	return 0
}
erase_key_history() {
	local key="$1"

	# Check if the key is provided
	if [[ -v "$key" ]]; then
		echo -e "\e[91mError: Key does not exist.\e[0m"
		return 1
	fi

	local found_history=false

	# Iterate through all keys in kv_store and delete matching history entries
	for history_key in "${!kv_store[@]}"; do
		if [[ "$history_key" == "__hst_0_${key}" || "$history_key" == __hst_*_${key} ]]; then
			unset kv_store["$history_key"]
			found_history=true
		fi
	done

	if [[ "$found_history" == true ]]; then
		#		echo -e "\e[92mHistory for key '$key' erased successfully.\e[0m"
		return 0
	else
		#		echo -e "\e[93mNo history found for key '$key'. Nothing to erase.\e[0m"
		return 1
	fi
}
# Recent global history is only used for current session, kept in mempry so we know latest changes
# Function to write to recent global history
write_recent_global_history() {
	local entry="$1"

	# Validate input
	if [[ -z "$entry" ]]; then
		echo -e "Recent global history: Error: Entry text is required."
		return 1
	fi

	# Append the entry to the recent_global_history array
	recent_global_history+=("$entry")

	return 0
}

# Function to print and colorize each line of the recent global history
print_recent_global_history() {
	if [[ ${#recent_global_history[@]} -eq 0 ]]; then
		echo -e "\e[93mNo recent global history available.\e[0m"
		return 0
	fi

	echo -e "Recent Global History:"
	echo -e "----------------------"

	for line in "${recent_global_history[@]}"; do
		# Extract the timestamp, key type, and operation
		timestamp="${line%% *}"
		rest="${line#* }"

		# Check if this is a Vault or Key entry
		if [[ "$rest" =~ ^Vault ]]; then
			operation="${rest#Vault }"
			echo -e "\e[95m$timestamp\e[0m \e[92mVault\e[0m $operation"
		else
			# Extract the key name and operation
			key="${rest#Key \'}"
			key="${key%%\' *}"
			operation="${rest#Key \'${key}\' }"
			echo -e "\e[95m$timestamp\e[0m Key '\e[93m$key\e[0m' $operation"
		fi
	done
}

# Function to get the number of entries in the recent global history
get_recent_global_history_count() {
	echo "${#recent_global_history[@]}"
}

# Function to clear the recent global history
clear_recent_global_history() {
	recent_global_history=()
	#echo -e "\e[92mRecent global history cleared.\e[0m"
}

## Ordinary global history, stored in vault, persistent
write_global_history() {
	local key="$1"
	local operation="$2"
	local is_vault_operation=false

	# If only one argument is provided, treat it as a vault operation
	if [[ -z "$operation" ]]; then
		operation="$key"
		is_vault_operation=true
	fi

	# Validate inputs
	if [[ -z "$operation" ]]; then
		echo -e "\e[91mError: Operation text is required.\e[0m"
		return 1
	fi

	# Get the current timestamp in ISO 8601 format
	local timestamp
	timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

	# Format the history entry based on the type (Vault or Key)
	local entry
	if [[ "$is_vault_operation" == true ]]; then
		entry="$timestamp Vault $operation"
	else
		entry="$timestamp Key '$key' $operation"
	fi

	# Prepend the entry to __global_history
	if [[ -v kv_store["__global_history"] ]]; then
		kv_store["__global_history"]="$entry"$'\n'"${kv_store["__global_history"]}"
	else
		kv_store["__global_history"]="$entry"
	fi

	#echo -e "\e[92mGlobal history updated successfully.\e[0m"

	# For or session history
	write_recent_global_history "$entry"
	return 0
}

unwrite_last_global_history() {
	# Check if the global history key exists
	if [[ -z "${kv_store["__global_history"]}" ]]; then
		echo -e "\e[91mError: No global history to unwrite.\e[0m"
		return 1
	fi

	# Read the current global history
	local current_history="${kv_store["__global_history"]}"

	# Remove the first entry (newest entry)
	local updated_history
	updated_history=$(echo -e "$current_history" | tail -n +2)

	# Update the global history
	kv_store["__global_history"]="$updated_history"

	# Optionally, remove from recent global history if needed
	if [[ ${#recent_global_history[@]} -gt 0 ]]; then
		unset 'recent_global_history[0]'
	fi

	echo -e "\e[92mLast global history entry removed successfully.\e[0m"
	return 0
}

# Clone kv_store
clone_kv_store() {
	for key in "${!kv_store[@]}"; do
		kv_store_clone["$key"]="${kv_store["$key"]}"
	done
}

# Restore kv_store from the clone
restore_kv_store() {
	# Clear kv_store
	for key in "${!kv_store[@]}"; do
		unset kv_store["$key"]
	done

	# Repopulate kv_store from the clone
	for key in "${!kv_store_clone[@]}"; do
		kv_store["$key"]="${kv_store_clone["$key"]}"
	done
}

# Function to check if a key should be ignored
ignore_this_key() {
	local key="$1"

	# Check if the key matches the __hst_* pattern
	if [[ "$key" =~ ^__hst_ ]]; then
		return 0 # True (key should be ignored)

	fi
	return 1
	if [[ "$key" =~ ^__marked_ ]]; then
		return 0 # True (key should be ignored)

	fi

	return 1 # False (key should not be ignored)
}

absorb_file_into_key() {
	echo -e $'\e[95mAbsorb File into Key\e[0m'

	# Prompt for the key name

	if ! is_marked_key_mode_active; then
		read -rp $'\e[96mEnter key name to store file content: \e[0m' key
	else
		key="$(marked_key_selected)"
	fi

	# Validate the key
	if [[ -z "$key" ]]; then
		echo -e "Error: Key cannot be empty."
		return
	elif [[ ! "$key" =~ ^[a-zA-Z0-9:._-]+$ ]]; then
		echo -e "Error: Invalid key name. Only letters, numbers, dots, dashes, colons, and underscores are allowed."
		return
	fi

	# Show the current working directory and prompt for the file path
	echo -e "Current Directory: $(pwd)"
	read -rp $'\e[96mEnter the file path to absorb: \e[0m' file_path

	# Expand the file path to handle relative paths and symlinks
	file_path=$(realpath -e "$file_path")

	# Check if the file exists
	if [[ ! -f "$file_path" ]]; then
		echo -e "Error: File does not exist at path: $file_path"
		return
	fi

	# Read the file content
	file_content=$(<"$file_path")

	# Save the previous content if key exists
	# Save the diff with the previous content if key exists
	if key_exists_in_kv_store "$key"; then
		# Compute the diff between the existing and new content
		diff_output=$(diff <(echo -n "${kv_store[$key]}") <(echo -n "$file_content"))

		# If there's a difference, save it in the history
		if [[ -n "$diff_output" ]]; then
			add_history_entry "$key" "$diff_output"

		fi
	fi

	# Store file content in the kv_store
	kv_store["$key"]="$file_content"

	# Log the operation
	bytes_written=$(wc -c <"$file_path")
	write_global_history "$key" "absorbed file '$file_path' ($bytes_written bytes)"
	unsaved_changes=1

	echo -e "\e[92mFile '$file_path' absorbed into key '$key'.\e[0m"
}

test_custom_crypto_functions_to_make_sure_they_work() {
	# Check if __ced and __cdd are set in kv_store

	if [[ -z "${kv_store["__ced"]}" || -z "${kv_store["__cdd"]}" ]]; then
		echo "Error: Custom encryption and decryption functions are not set. Both or none are missing."
		return 1
	fi

	custom_encrypt_data="${kv_store["__ced"]}"
	custom_decrypt_data="${kv_store["__cdd"]}"

	# Check syntax for the encryption command
	if ! bash -n <<<"$custom_encrypt_data"; then
		echo "Syntax Error: Encryption command has invalid syntax."
		return 1
	fi

	# NOTE: the eval here should succeed given syntax is correct, because it is just a functoin definition in custom_*_data
	# Execute the encryption command
	eval "$custom_encrypt_data"
	if [[ $? -ne 0 ]]; then
		echo "Runtime Error: Encryption command failed."
		return 1
	fi

	# Check syntax for the decryption command
	if ! bash -n <<<"$custom_decrypt_data"; then
		echo "Syntax Error: Decryption command has invalid syntax."
		return 1
	fi

	# Execute the decryption command
	eval "$custom_decrypt_data"
	if [[ $? -ne 0 ]]; then
		echo "Runtime Error: Decryption command failed."
		return 1
	fi

	# Directly check if both functions are defined
	if ! declare -f "custom_encrypt_data" >/dev/null; then
		echo "Error: Function 'custom_encrypt_data' is NOT defined."
		return 1
	fi

	if ! declare -f "custom_decrypt_data" >/dev/null; then
		echo "Error: Function 'custom_decrypt_data' is NOT defined."
		return 1
	fi

	# Do a simple encryption test
	local test_data="test data"
	local pwd="the_password"
	enc_data=$(custom_encrypt_data "$test_data" "$pwd" "2")
	dec_data=$(custom_decrypt_data "$enc_data" "$pwd" "2")
	# Check if the decrypted data matches the original test data
	if [[ "$dec_data" != "$test_data" ]]; then
		return 1

	else
		return 0
	fi
}
dump_kv_store_to_dir() {
	local target_dir
	local dump_dir
	local sanitized_key
	local invalid_chars='[^a-zA-Z0-9._-]'

	# Prompt for directory, default to current directory
	read -rp "Enter target directory to dump kv_store (default: $(pwd)): " target_dir
	target_dir="${target_dir:-$(pwd)}"

	# Define the dump directory as target_dir/cred-dump
	dump_dir="$target_dir/cred-dump"

	# Check if the dump directory exists, if not create it
	if [[ ! -d "$dump_dir" ]]; then
		echo "Creating dump directory: $dump_dir"
		mkdir -p "$dump_dir" || {
			echo "Failed to create dump directory. Exiting."
			return 1
		}
	fi

	# Iterate through kv_store and create files for each key
	for key in "${!kv_store[@]}"; do
		# Skip ignored keys (like history keys)
		if ignore_this_key "$key"; then
			continue
		fi

		# Sanitize key to make it a valid filename
		sanitized_key=$(echo "$key" | sed -E "s/$invalid_chars/_/g")

		# Write the value to the file in the dump directory
		echo -n "${kv_store[$key]}" >"$dump_dir/$sanitized_key"

		echo "Dumped key '$key' to '$dump_dir/$sanitized_key'"
	done

	echo "Dump complete. All keys have been saved to: $dump_dir"
}

# Deserialize marked keys from kv_store
# Deserialize marked keys from kv_store
# Deserialize marked keys from kv_store (defaults to space delimiter)
deserialize_marked_keys() {
	read -ra marked_keys <<<"${kv_store[__marked_key_all]}"
}

# Serialize marked keys back into kv_store (defaults to space delimiter)
serialize_marked_keys() {
	kv_store[__marked_key_all]="${marked_keys[*]}"
}

# Return all marked keys except the provided key

marked_keys_exclude() {
	local exclude_key="$1"
	deserialize_marked_keys

	for key in "${marked_keys[@]}"; do
		if [[ "$key" != "$exclude_key" ]]; then
			echo "$key"
		fi
	done
}
# Set the provided key as the currently selected marked key
marked_key_set_selected() {
	local target_key="$1"
	# Trim trailing newline characters
	target_key="${target_key//$'\n'/}"

	deserialize_marked_keys

	for i in "${!marked_keys[@]}"; do
		if [[ "${marked_keys[$i]}" == "$target_key" ]]; then
			kv_store[__marked_key_pos]="$i"
			return 0 # Success
		fi
	done

	echo "Key '$target_key' is not marked."
	return 1 # Failure
}

# Add a key to the marked list
marked_key_add() {
	local key="$1"
	deserialize_marked_keys

	# Trim trailing newline characters
	key="${key//$'\n'/}"

	# Add only if the key isn't already marked
	for existing_key in "${marked_keys[@]}"; do
		if [[ "$existing_key" == "$key" ]]; then
			return 0 # Key already exists, no need to add
		fi
	done

	# Add the key if it's not present
	marked_keys+=("$key")
	serialize_marked_keys
	echo "added key $key"
	# If this is the first key, mark it as active
	if [[ -z "${kv_store[__marked_key_pos]}" ]]; then
		kv_store[__marked_key_pos]=0
	fi
}

# Remove a key from the marked list
marked_key_remove() {
	local key="$1"
	deserialize_marked_keys

	for i in "${!marked_keys[@]}"; do
		if [[ "${marked_keys[$i]}" == "$key" ]]; then
			unset 'marked_keys[i]'
			marked_keys=("${marked_keys[@]}") # Reindex the array
			serialize_marked_keys

			# Adjust the position if needed
			if [[ "${kv_store[__marked_key_pos]}" -ge "${#marked_keys[@]}" ]]; then
				kv_store[__marked_key_pos]=$((${#marked_keys[@]} - 1))
			fi

			# Clear position if the array is empty
			if [[ "${#marked_keys[@]}" -eq 0 ]]; then
				unset kv_store[__marked_key_pos]
			fi
			break
		fi
	done
}

# Cycle to the next marked key
marked_key_next() {
	deserialize_marked_keys
	local count=${#marked_keys[@]}
	if ((count == 0)); then
		echo "No marked keys."
		return
	fi

	kv_store[__marked_key_pos]=$(((kv_store[__marked_key_pos] + 1) % count))
}
# Return the total number of marked keys
marked_key_count() {
	deserialize_marked_keys
	echo "${#marked_keys[@]}"
}

# Cycle to the previous marked key
marked_key_previous() {
	deserialize_marked_keys
	local count=${#marked_keys[@]}
	if ((count == 0)); then
		echo "No marked keys."
		return
	fi

	kv_store[__marked_key_pos]=$(((kv_store[__marked_key_pos] - 1 + count) % count))
}

# Display all marked keys, highlighting the current one
marked_key_all() {
	deserialize_marked_keys
	for i in "${!marked_keys[@]}"; do
		if [[ "$i" -eq "${kv_store[__marked_key_pos]}" ]]; then
			echo -e "[*] ${marked_keys[$i]}" # Highlight current key
		else
			echo "    ${marked_keys[$i]}"
		fi
	done
}

# Show the currently selected marked key
marked_key_selected() {
	deserialize_marked_keys
	local pos="${kv_store[__marked_key_pos]}"
	if [[ -n "${marked_keys[$pos]}" ]]; then
		echo "${marked_keys[$pos]}"
	else
		echo "No marked key."
	fi
}

is_marked_key_mode_active() {
	# Check if marked key mode is enabled
	if [[ "$is_marked_key_mode" -ne 1 ]]; then
		return 1 # Marked key mode is OFF
	fi

	# Deserialize the marked keys
	deserialize_marked_keys

	# Check if the marked keys array is not empty
	if [[ ${#marked_keys[@]} -eq 0 ]]; then
		return 1 # No marked keys
	fi

	# Check if __marked_key_pos is set and points to a valid key
	local pos="${kv_store[__marked_key_pos]}"
	if [[ -n "$pos" ]] && [[ "$pos" =~ ^[0-9]+$ ]] && [[ "$pos" -lt ${#marked_keys[@]} ]]; then
		return 0 # Active and valid position
	else
		return 1 # Invalid or unset position
	fi
}

# Main function
main() {
	local data_file=""
	local data_file_is_remote=0
	local extract_key=""
	local create_new=0
	local iterations="10000" # Default iterations
	declare -A opt_store
	declare -A kv_store
	# TODO: cloe functions not used
	declare -A kv_store_clone
	declare -a recent_global_history=()
	local encrypted_data=""
	local password=""
	local metadata
	local unsaved_changes=0
	local last_confirmation
	local is_marked_key_mode=0
	local print_only_bottom_of_prompt=0
	local marked_keys=()

	# Argument parsing loop
	while [[ "$1" ]]; do
		case "$1" in
		-e)
			shift
			if [[ "$1" && "$1" != -* ]]; then
				extract_key="$1"
				shift
			else
				echo "Error: No keys specified for extraction after '-e'."
				exit 1
			fi
			;;
		-h)
			echo "Usage: ./cred [-e key] [-n] <vaultfile>"
			echo
			echo "Options:"
			echo "  -e key      Extract the value of the specified key. \"key1 key2 ...\" for multiple keys."
			echo "  -n          Create a new vault file."
			echo "  -h          Display this help message."
			echo
			echo "Examples:"
			echo "  # Open the vault interactively:"
			echo "  ./cred my-vault"
			echo
			echo "  # Extract the value of a key:"
			echo "  ./cred -e key1 my-vault"
			echo
			echo "  # Pipe a password and extract a key:"
			echo "  echo \"mypassword\" | ./cred -e key1 my-vault"
			echo
			echo "  # Create a new vault:"
			echo "  ./cred -n my-vault"
			exit 0
			;;
		-n)
			create_new=1
			shift
			;;
		--*)                             # Handle long options
			option_name=${1:2}              # Remove the '--' prefix
			key="__opt_${option_name//-/_}" # Replace '-' with '_'
			shift
			if [[ -n "$1" && "$1" != -* ]]; then
				opt_store["$key"]="$1" # Assign the value to the key
				shift
			else
				opt_store["$key"]=1 # Set to 1 if no value is provided
			fi
			;;
		-*)                        # Handle short options
			option_name=${1:1}        # Remove the '-' prefix
			key="_opt_${option_name}" # Prefix with '__opt_'
			shift
			if [[ -n "$1" && "$1" != -* ]]; then
				opt_store["$key"]="$1" # Assign the value to the key
				shift
			else
				opt_store["$key"]=1 # Set to 1 if no value is provided
			fi
			;;
		*)
			if [[ -z "$data_file" ]]; then
				data_file="$1"
				if is_remote_file "$data_file"; then
					data_file_is_remote=1
				fi
			else
				echo "Error: Multiple data files specified: '$data_file' and '$1'."
				exit 1
			fi
			shift
			;;
		esac
	done

	if [[ -z "$data_file" && "$create_new" -eq 0 ]]; then
		echo "Error: No data file specified and '-n' (create new) option not set."
		echo "Usage: $0 [-e key] [-n] <data_file>"
		exit 1
	fi

	# Handle the `-e` logic after parsing
	if [[ -n "$extract_key" ]]; then
		if [[ -z "$data_file" ]]; then
			echo "Error: No data file specified."
			exit 1
		fi

		# Read the password
		if read -t 0; then
			read -rs password
		else
			read -rsp "Enter password for $data_file: " password
			echo
		fi

		# Parse metadata
		metadata=$(parse_metadata "$data_file")
		eval "declare -A metadata=${metadata#*=}"

		# Extract encrypted data and iterations
		encrypted_data="${metadata['encrypted-data']}"
		iterations="${metadata['number-of-iterations']}"

		# Decrypt the data
		#		decrypted_data=$(decrypt_data "$encrypted_data" "$password" "$iterations")

		if [[ -n "${metadata['decryption-function']}" ]]; then
			# the decryption function exist in metadata and is base64 encoded, decode it
			decryption_function=$(echo -n "${metadata['decryption-function']}" | base64 -d)
			eval "$decryption_function"

			if declare -F custom_decrypt_data >/dev/null; then
				decrypted_data=$(custom_decrypt_data "$encrypted_data" "$password" "$iterations")
			else
				echo "metadata[decryption_function] exists but doesnt resolve to custom_decrypt_function"
			fi

		else
			decrypted_data=$(decrypt_data "$encrypted_data" "$password" "$iterations")
		fi

		if [[ "$decrypted_data" == *"bad decrypt"* ]]; then
			echo "Error decrypting data. Incorrect password or corrupted file."
			exit 1
		fi

		# Load data into the associative array
		# TODO: Why declare it again?
		#		declare -A kv_store
		#		while IFS= read -r key && IFS= read -r value; do
		#			decoded_value=$(echo -n "$value" | base64 -d)
		#			kv_store["$key"]="$decoded_value"
		#		done <<<"$decrypted_data"

		# Restore kv_store
		eval "$decrypted_data"

		# Call the extract_keys function with the loaded kv_store
		extract_keys "$extract_key"
		exit 0
	elif [[ $create_new -eq 1 ]]; then
		if [[ -z "$data_file" ]]; then
			echo "Please specify a file name for the new vault."
			exit 1
		fi

		if is_remote_file "$file"; then
			echo "Error: Cannot create a new vault with a remote file. New vault creation must have local path provided."
			exit 1
		fi

		if [[ -f "$data_file" ]]; then
			echo "Error: File '$data_file' already exists. Choose a different name or delete the existing file."
			exit 1
		fi

		# Check if password is being piped
		if ! [ -t 0 ]; then
			# Read password from pipe
			read -r password
			# Redirect stdin to /dev/tty to ensure further inputs are from the terminal
			exec </dev/tty
			confirm_password="$password" # Assume confirmation matches when piped
		else

			# Prompt for password twice to confirm
			while true; do
				read -rsp "Enter password for new vault: " password
				echo
				read -rsp "Confirm password: " confirm_password
				echo

				if [[ "$password" == "$confirm_password" ]]; then
					# Passwords match
					break
				else
					echo "Error: Passwords do not match. Please try again."
				fi
			done
		fi
		# Initialize encrypted-data with an empty base64 string
		write_global_history "created"
		unsaved_changes=1
		last_confirmation=$'\e[92mNew vault created: '"$data_file"$'\e[0m'
	elif [[ $data_file_is_remote -eq 1 || -f "$data_file" ]]; then
		# Prompt for password
		if read -t 0; then
			read -rs password
			# Redirect stdin to /dev/tty to ensure further inputs are from the terminal
			exec </dev/tty
		else
			read -rsp "Enter password for $data_file: " password
			echo
		fi

		# Parse metadata
		metadata=$(parse_metadata "$data_file")
		eval "declare -A metadata=${metadata#*=}"

		# Extract encrypted data and iterations
		encrypted_data="${metadata['encrypted-data']}"
		iterations="${metadata['number-of-iterations']}"

		# Decrypt the data
		#if decryption function exist in metadata, use it
		if [[ -n "${metadata['decryption-function']}" ]]; then
			# the decryption function exist in metadata and is base64 encoded, decode it
			decryption_function=$(echo -n "${metadata['decryption-function']}" | base64 -d)
			eval "$decryption_function"

			if declare -F custom_decrypt_data >/dev/null; then
				decrypted_data=$(custom_decrypt_data "$encrypted_data" "$password" "$iterations")
			else
				echo "metadata[decryption_function] exists but doesnt resolve to custom_decrypt_function"
			fi

		else
			decrypted_data=$(decrypt_data "$encrypted_data" "$password" "$iterations")
		fi

		if [[ "$decrypted_data" == *"bad decrypt"* ]]; then
			echo "Error decrypting data. Incorrect password or corrupted file."
			exit 1
		fi

		# Load data into the associative array
		#		while IFS= read -r key && IFS= read -r value; do
		#			# Decode the base64-encoded value
		#			decoded_value=$(echo -n "$value" | base64 -d)
		#
		#			# Store the key and decoded value in kv_store
		#			kv_store["$key"]="$decoded_value"
		#		done <<<"$decrypted_data"

		# Restore kv_store
		eval "$decrypted_data"

	else
		echo "No file found. Use -n to create a new vault."
		exit 1
	fi

	if key_exists_in_kv_store "__info"; then
		# Iterate through each line of the __info content
		while IFS= read -r line; do
			echo -e "\e[94mINFO\e[32m:\e[0m\e[0m $line"
		done <<<"${kv_store[__info]}"
	fi

	while true; do

		# Check if last_confirmation is set
		if [[ -n "$last_confirmation" ]]; then
			# Process last_confirmation with the function and update it
			last_confirmation=$(print_confirmation "$last_confirmation")
		else
			# Set it to an empty string
			last_confirmation=""
		fi

		if [[ -n "$last_confirmation" ]]; then
			echo -ne $last_confirmation
			echo
			last_confirmation=""
		fi
		vault_stats=$(calculate_kv_store_summary)
		if [[ $print_only_bottom_of_prompt -eq 0 ]]; then

			#### Styling the filepath
			MAGENTA='\033[95m' # Bright magenta
			BLUE='\033[94m'    # Bright blue
			RESET='\033[0m'

			# 1) Detect if the path starts with http:// or https://
			if [[ "$data_file" == http://* || "$data_file" == https://* ]]; then
				# Extract the protocol (http:// or https://)
				protocol="${data_file%%://*}://"
				# Extract the remaining part of the URL
				path="${data_file#*://}"

				# Color the protocol in bright magenta
				data_file_styled="${MAGENTA}${protocol}${RESET}"

				# Reconstruct data_file for normal processing
				data_file="$path"
			else
				# If not a URL, process as is
				data_file_styled=''
			fi

			# 2) Find the index of the last slash in the path
			last_slash_idx=-1
			for ((i = 0; i < ${#data_file}; i++)); do
				char="${data_file:$i:1}"
				if [[ "$char" == "/" ]]; then
					last_slash_idx=$i
				fi
			done

			# 3) Build the styled path character by character
			for ((i = 0; i < ${#data_file}; i++)); do
				char="${data_file:$i:1}"

				if [[ "$char" == "/" ]]; then
					# Color slashes in bright magenta
					data_file_styled+="${MAGENTA}/${RESET}"
				elif ((i > last_slash_idx)); then
					# Color the filename in bright blue
					data_file_styled+="${BLUE}${char}${RESET}"
				else
					# Keep normal characters
					data_file_styled+="$char"
				fi
			done

			# 4) Print the result in one line

			##############
			printf "┌─%b \033[90m%s\033[0m\n" "$data_file_styled" "$vault_stats"
			# 3) Print, making sure escape codes are interpreted (%b)

			for key in "${!opt_store[@]}"; do
				# Check if the key starts with '__opt_' or '_opt_' and handle accordingly
				if [[ "$key" == __opt_* ]]; then
					# Double dash for '__opt_'
					stripped_key="${key#__opt_}"
					prefix="--"
				elif [[ "$key" == _opt_* ]]; then
					# Single dash for '_opt_'
					stripped_key="${key#_opt_}"
					prefix="-"
				else
					# No prefix change if it doesn't match
					stripped_key="$key"
					prefix=""
				fi

				# Replace remaining underscores with hyphens
				formatted_key="${stripped_key//_/-}"

				# Print with appropriate prefix
				echo -e "├\e[90m  \e[0m${prefix}${formatted_key}\e[90m ${opt_store[$key]}\e[0m"
			done
		fi
		#print the filename in magenta

		## The prompt

		# Get the number of entries in recent_global_history
		hist_count="${#recent_global_history[@]}"
		# Determine the color based on the count
		if [[ "$hist_count" -eq 0 ]]; then
			color="\e[92m" # Green for 0
		else
			color="\e[91m" # Red for non-zero
		fi

		if is_marked_key_mode_active; then

			local current_key
			current_key="$(marked_key_selected)"

			# Get all other marked keys excluding the current one
			local other_keys
			other_keys="$(marked_keys_exclude "$current_key")"

			# Build the display string
			local display=""
			for key in $other_keys; do
				display+="\e[90m${key}\e[0m " # Dim other keys
			done

			# Highlight the current key in bright yellow
			display+="\e[93m${current_key}\e[0m"
			# Compose and print the prompt
			echo -ne "└──$color($hist_count)\e[0m \e[96mkeys: [\e[0m $display \e[96m]\e[0m \e[96m> \e[0m"
			#	echo -ne "└──$color($count)\e[0m "$'\e[96m(in marked key mode, but no marked key) > \e[0m'

		else

			echo -ne "└──$color($hist_count)\e[0m "$'\e[96m> \e[0m'
		fi

		print_only_bottom_of_prompt=0

		##
		read -n 1 -s command
		echo -n $command
		echo # Move to the next line after user input
		case "$command" in
		'?')
			print_help
			;;
		a)
			absorb_file_into_key
			;;
		m)
			# Mark mode returns 0 on success
			selected_key="$(mark_mode)"
			# Check if a key was selected
			if [[ -n "$selected_key" ]]; then
				# Add the key to the marked list first
				marked_key_add "$selected_key"

				# Set the selected key using the helper function
				if marked_key_set_selected "$selected_key"; then
					echo -e "\e[92mMarked key: $(marked_key_selected)\e[0m"
					is_marked_key_mode=1
					print_only_bottom_of_prompt=1

					print_help_key
				else
					echo -e "Failed to select key '$selected_key'."
				fi
			else
				echo -e "No key selected."
			fi

			continue
			;;

		M)
			# Toggle marked key mode
			if [[ "$is_marked_key_mode" -eq 1 ]]; then
				last_confirmation=$'\e[92mExited key-marking mode\e[0m'
				is_marked_key_mode=0
			else
				last_confirmation=$'\e[92mEntered key-marking mode\e[0m'
				is_marked_key_mode=1
			fi
			print_only_bottom_of_prompt=1
			continue

			;;
		n)
			# Cycle/Toggle to previous marked key
			marked_key_next

			print_only_bottom_of_prompt=1
			;;
		N)
			# Cycle/Toggle to previous marked key
			marked_key_previous

			print_only_bottom_of_prompt=1
			;;

		,)
			marked_key_remove "$(marked_key_selected)"
			;;
		':')
			echo -e $'\e[91mCommand Mode\e[0m'

			while true; do
				echo -e "\n\e[91mAvailable commands:\e[0m"
				echo -e " \e[91dump-key\e[0m - Dump all keys to a directory"
				echo -e " \e[91merase-history-for-key\e[0m - Erase all history for a specific key"
				echo -e " \e[91merase-history-for_all-keys\e[0m - Erase all history entries for all keys"
				echo -e " \e[91msanitize-keys\e[0m - Change all '-' for '_' in key names like MY-KEY to MY_KEY"
				echo -e " \e[91mq\e[0m - Quit command mode"

				# Prompt for a command
				echo -ne "\e[91mType a command: \e[0m"
				read -r command

				case "$command" in
				dump-keys)
					dump_kv_store_to_dir
					;;
				sanitize-keys)
					echo -e "\e[95mSanitizing Keys (Replacing '-' with '_')\e[0m"

					# Temporary associative array to hold sanitized keys
					declare -A sanitized_kv_store

					# Flag to check if any keys were changed
					local keys_changed=0

					# Loop through all keys in kv_store
					for key in "${!kv_store[@]}"; do
						# Replace '-' with '_'
						sanitized_key="${key//-/_}"

						# If the sanitized key is different, update the flag
						if [[ "$key" != "$sanitized_key" ]]; then
							keys_changed=1
							echo -e "\e[93mRenamed:\e[0m '$key' -> '$sanitized_key'"
						fi

						# Store in the new sanitized_kv_store
						sanitized_kv_store["$sanitized_key"]="${kv_store[$key]}"
					done

					# Replace the original kv_store with the sanitized version
					kv_store=()
					for key in "${!sanitized_kv_store[@]}"; do
						kv_store["$key"]="${sanitized_kv_store[$key]}"
					done

					# If any keys were changed, log and set unsaved changes
					if [[ $keys_changed -eq 1 ]]; then
						write_global_history "[all]" "sanitized keys (replaced '-' with '_')"
						unsaved_changes=1
						echo -e "\e[92mSanitization complete.\e[0m"
					else
						echo -e "\e[93mNo keys required sanitization.\e[0m"
					fi
					;;
				erase-history-for-key)
					echo -ne "\e[91mEnter the key to erase all history for: \e[0m"
					read -r key

					# Call erase_key_history function
					if erase_key_history "$key"; then
						echo -e "History erased successfully for key: $key"
					else
						echo -e "\e[91mNothing to erase for given key: '$key'\e[0m"
					fi
					write_global_history "$key" "deleted history"
					unsaved_changes=1
					;;
				erase-history-for-all_keys)
					# Confirm erasing all history
					echo -ne "\e[91mAre you sure you want to erase all history? (y/n): \e[0m"
					read -r confirm
					if [[ "$confirm" == "y" ]]; then
						local deleted_any=false

						for history_key in "${!kv_store[@]}"; do
							if [[ "$history_key" == __hst_* ]]; then
								unset kv_store["$history_key"]
								deleted_any=true
							fi
						done

						if [[ "$deleted_any" == true ]]; then
							echo -e "All history entries erased successfully."
							write_global_history "[all]" "deleted history"
							unsaved_changes=1
						else
							echo -e "\e[93mNo history entries were found to delete.\e[0m"
						fi
					else
						echo -e "\e[93mOperation canceled.\e[0m"
					fi
					;;
				q)
					echo -e "\e[91mExiting command mode.\e[0m"
					break
					;;
				*)
					echo -e "\e[91mInvalid command. Please try again.\e[0m"
					;;
				esac
			done
			;;

		h)
			#If is_marked_key_mode is note set, read key
			if ! is_marked_key_mode_active; then
				echo -ne "\e[96mEnter the key to list its history: \e[0m"
				read -r key
			else
				key="$(marked_key_selected)"

			fi

			if [[ -z "$key" ]]; then
				echo -e "\e[93mNo key entered. Operation cancelled.\e[0m"
				return
			fi

			output=$(list_history_entries "$key")
			status=$?

			if [[ $status -eq 0 ]]; then
				echo "$output" | less -R
			else
				echo "$output"
			fi
			;;
		G)
			# Check if __global_history exists in kv_store
			if [[ -z "${kv_store["__global_history"]}" ]]; then
				echo -e "\e[93mNo global history found.\e[0m"
				continue
			fi

			# Parse and colorize the global history
			{
				echo -e "\e[96mGlobal History:\e[0m"
				echo -e "\e[90m----------------\e[0m"

				# Read the global history line by line
				while IFS= read -r line; do
					# Extract the timestamp, key type, and operation
					timestamp="${line%% *}"
					rest="${line#* }"

					# Check if this is a Vault or Key entry
					if [[ "$rest" =~ ^Vault ]]; then
						operation="${rest#Vault }"
						echo -e "\e[95m$timestamp\e[0m \e[92mVault\e[0m $operation"
					else
						# Extract the key name and operation
						key="${rest#Key \'}"
						key="${key%%\' *}"
						operation="${rest#Key \'${key}\' }"
						echo -e "\e[95m$timestamp\e[0m Key '\e[93m$key\e[0m' $operation"
					fi
				done <<<"${kv_store["__global_history"]}"

			} | less -R
			;;

		s)

			echo -e $'\e[95mSet Key\e[0m'

			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disablied: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi

			if ! is_marked_key_mode_active; then
				# Prompt for key
				read -rp $'\e[96mEnter key: \e[0m' key
			else
				key="$(marked_key_selected)"
			fi

			# Validate the key
			if [[ -z "$key" ]]; then
				last_confirmation="Error: Key cannot be empty."
				continue
			elif [[ ! "$key" =~ ^[a-zA-Z0-9:._-]+$ ]]; then

				last_confirmation="Error: Key contains illegal characters. Only letters, numbers, dots, dashes, colon, and underscores are allowed."
				continue
			fi

			# Prompt for value
			read -rp $'\e[93mEnter value: \e[0m' value

			# if key exists, add current to history
			if key_exists_in_kv_store "$key"; then
				add_history_entry "$key"
			fi

			# Store the key-value pair
			kv_store["$key"]="$value"

			# Save to history and write how many bytes are written
			bytes_written=$(echo -n "$value" | wc -c)
			write_global_history "$key" "set ($bytes_written bytes)"

			unsaved_changes=1
			last_confirmation=$'\e[92mKey \''"$key"$'\' and value set.\e[0m'
			;;
		I) # Option to display the __info content
			echo -e $'\e[95mDisplay Info\e[0m'
			if key_exists_in_kv_store "__info"; then
				# Print each line of __info content with the blue INFO: prefix
				while IFS= read -r line; do
					echo -e "\e[94mINFO:\e[0m $line"
				done <<<"${kv_store[__info]}"
			else
				echo -e "\e[91mNo info available.\e[0m"
			fi
			;;
		u)

			echo -e $'\e[95mUnset Key\e[0m'

			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi

			if ! is_marked_key_mode_active; then
				read -rp $'\e[96mEnter key to delete: \e[0m' key
			else
				key="$(marked_key_selected)"

			fi

			if [[ -z "$key" ]]; then
				echo "Error: Key cannot be empty."
			elif [[ -n "${kv_store[$key]}" ]]; then
				# Save to history
				add_history_entry "$key"

				bytes_unset=$(echo -n "${kv_store[$key]}" | wc -c)
				write_global_history "$key" "unset ($bytes_unset bytes)"
				unset kv_store["$key"]
				unsaved_changes=1
				last_confirmation=$'\e[92mKey \''"$key"$'\' and value unset.\e[0m'
			else
				last_confirmation="Error: Key '$key' does not exist."
			fi

			;;
		e) # New 'edit' option for editing a key-value pair
			echo -e $'\e[95mEdit Key Value\e[0m'
			if ! is_marked_key_mode_active; then

				# Prompt for key to edit
				read -rp $'\e[96mEnter key to edit: \e[0m' key

			else
				key="$(marked_key_selected)"

			fi

			if [[ -z "$key" ]]; then
				last_confirmation="Error: Key cannot be empty."
				continue
			fi

			# Get current value of the key
			current_value="${kv_store[$key]}"

			did_update_content=0

			# We have different editors possible, so we need to check which one to use
			if [[ -n "$USE_EDITOR" && "$USE_EDITOR" != "micro" && "$USE_EDITOR" != "default" ]]; then
				# Create a temporary file
				temp_file=$(mktemp)

				# Write the current value to the temporary file
				printf %s "$current_value" >"$temp_file"
				# Open the temporary file in nvim
				$USE_EDITOR "$temp_file"
				temp_file_content=$(<"$temp_file")

				# Trim temp_file and current_value end to remove newlines
				# NOTE: 1 newline is adedd by for example Neovim as by POSIX standard, but the user may have formatters etc that add more
				# Thus trim all newlines from the end before compare to check for changes
				current_value_trim=$(printf "%s" "$current_value" | awk '{ sub(/\n+$/, ""); print }')
				temp_file_content_trim=$(printf "%s" "$temp_file_content" | awk '{ sub(/\n+$/, ""); print }')

				if [[ "$current_value_trim" != "$temp_file_content_trim" ]]; then
					# File was modified, update the edited value
					edited_value=$(cat "$temp_file")
					did_update_content=1
				else
					# No change was made
					did_update_content=0
				fi

				# Shred and delete the temporary file
				shred -u -n 20 "$temp_file"

			else
				# Pipe current value to 'micro' and allow the user to edit it
				edited_value=$(echo -n "$current_value" | micro)
				did_update_content=1
			fi

			# If the value was edited, update it in kv_store
			if [[ $did_update_content -eq 1 ]]; then
				# Put it down here, because we still allow user to open the value in editor
				if ! allow_edit "$data_file" "$data_file_is_remote"; then
					last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
					continue
				fi
				# Use `diff` to compare the old and new values and save that to history
				old_value="${kv_store[$key]}"

				# Create a diff between old and new values
				diff_output=$(diff <(echo "$old_value") <(echo "$edited_value"))

				add_history_entry "$key" "$diff_output"
				kv_store["$key"]="$edited_value"

				bytes_written=$(echo -n "$edited_value" | wc -c)
				write_global_history "$key" "edited ($bytes_written bytes)"

				unsaved_changes=1

				last_confirmation=$'\e[92mKey \''"$key"$'\' value updated.\e[0m'
			else
				last_confirmation=$'\e[93mNo changes made to key \''"$key"$'\'.\e[0m'
			fi
			;;
		v)
			echo -e $'\e[95mView Keys\e[0m'

			# Print header and keys with colors, then pipe to less
			{
				echo -e "\e[96mALL KEYS\e[0m"
				echo -e "\e[90m--------\e[0m"
				for k in "${!kv_store[@]}"; do
					# Skip keys that should be ignored
					if ignore_this_key "$k"; then
						continue
					fi
					# Determine the length of the key for padding
					local padding=$(printf "%$((${#k} + 2))s")

					# Split the value into lines and process each line
					echo -en "\e[93m$k\e[0m: " # Key in bright yellow
					first_line=true
					line_count=0
					while IFS= read -r line; do
						if $first_line; then
							echo -e "$line" # Default text for the first line
							first_line=false
						else
							# Print up to 3 additional lines
							((line_count++))
							if ((line_count <= 3)); then
								echo -e "\e[90m$padding$line\e[0m" # Indent subsequent lines
							fi
						fi
					done <<<"${kv_store[$k]}"
				done
			} | less -R
			;;

			#		v)
			#			echo -e $'\e[95mView Keys\e[0m'
			#			read -rp $'\e[96mEnter key to show (leave empty for all): \e[0m' key
			#			if [[ -z "$key" ]]; then
			#				# View all keys, pipe to less
			#				for k in "${!kv_store[@]}"; do
			#					echo "$k: ${kv_store[$k]}"
			#				done | less
			#			else
			#				# View specific key, pipe to less
			#				if [[ -n "${kv_store[$key]}" ]]; then
			#					echo "$key: ${kv_store[$key]}" | less
			#				else
			#					echo "Key '$key' not found." | less
			#				fi
			#			fi
			#			;;
		y)
			echo -e $'\e[95mYank Key to Clipboard\e[0m'
			if ! is_marked_key_mode_active; then

				read -rp $'\e[96mEnter key to yank: \e[0m' key
			else
				key="$(marked_key_selected)"
			fi
			if [[ -n "${kv_store[$key]}" ]]; then
				# Copy the value of the specified key to the clipboard using xsel
				echo -n "${kv_store[$key]}" | xsel --clipboard --input
				last_confirmation=$'\e[92mKey \''"$key"$'\' value copied to clipboard.\e[0m'
			else
				last_confirmation="Error: Key '$key' not found."
			fi
			;;
		r) # New 'rename' option for renaming a key

			echo -e $'\e[95mRename Key\e[0m'
			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi

			if ! is_marked_key_mode_active; then
				# Prompt for the current (target) key to rename
				read -rp $'\e[96mEnter the key to rename: \e[0m' old_key
			else
				old_key="${kv_store["__marked_key"]}"
			fi
			# Check if the old key exists
			if [[ -z "$old_key" ]]; then
				last_confirmation="Error: Key cannot be empty."
				continue
			elif [[ -v "${kv_store[$old_key]}" ]]; then
				last_confirmation="Error: Key '$old_key' does not exist."
				continue
			fi

			# Prompt for the new key name
			read -rp $'\e[96mEnter new name for the key: \e[0m' new_key

			# Validate the new key name
			if [[ -z "$new_key" ]]; then
				last_confirmation="Error: New key name cannot be empty."
				continue
			elif [[ ! "$new_key" =~ ^[a-zA-Z0-9:._-]+$ ]]; then
				last_confirmation="Error: New key name contains illegal characters. Only letters, numbers, dots, dashes, colon, and underscores are allowed."
				continue
			fi

			# Check if the new key already exists
			if [[ -n "${kv_store[$new_key]}" ]]; then
				last_confirmatoin="Error: Key '$new_key' already exists. Please choose a different name."
				continue
			fi

			# At this point we know the new name is not occupied, thus we wont eraze any data by accidental overwriting

			# Rename the key by creating a new key-value pair and removing the old one
			kv_store["$new_key"]="${kv_store[$old_key]}"

			# We do not rename existing history entries, or we may overwrite history of another key
			# Save a copy before deleting
			add_history_entry "$old_key"

			unset kv_store["$old_key"]

			write_global_history "$old_key" "renamed to '$new_key'"
			unsaved_changes=1
			last_confirmation=$'\e[92mKey \''"$old_key"$'\'renamed successfully to \''"$new_key"$'\'.\e[0m'
			;;
		t)
			test_custom_crypto_functions_to_make_sure_they_work
			if [[ $? -eq 0 ]]; then
				# Print success message in green
				echo -e "\033[92m[SUCCESS]\033[0m Custom encryption and decryption work correctly."
			else
				# Print bright red error message
				echo -e "\033[91m[ERROR]\033[0m Custom decrypted test data does not match the original!"
			fi
			;;
		w)
			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				echo -e $'\e[95mWrite data to file\e[0m'
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi

			if [[ $unsaved_changes -ne 1 ]]; then
				last_confirmation=$'\e[93mNo changes made. Nothing changes to write.\e[0m'
				continue
			fi

			# NOTE: Before anything, we need to ensure that the custom crypto functions work, or we may be locked out

			# Make sure not just one exists, the custom crypto functions
			if [[ -n "${kv_store["__ced"]}" || -n "${kv_store["__cdd"]}" ]]; then

				if [[ -n "${kv_store["__ced"]}" && -n "${kv_store["__cdd"]}" ]]; then
					echo "Making sure custom crypto functions work"
					# Both are set, so we have custom crypto functions
					test_custom_crypto_functions_to_make_sure_they_work
					if [[ $? -eq 0 ]]; then
						# Print success message in green
						echo -e "\033[92m[SUCCESS]\033[0m Custom encryption and decryption work correctly."
					else
						# Print bright red error message
						echo -e "\033[91m[ERROR]\033[0m Custom decrypted test data does not match the original!"
						last_confirmation="Aborting write. Error: Custom crypto functions do not work correctly."
						confintue
					fi
					:
				else
					echo "Either __ced or __cdd is unset or empty in kv_store"
					last_confirmation="Error: only one of __ced and __cdd are set. Both or none must be set."
					continue
				fi
			else
				# None of them are set, so we do not have custom crypto functions
				:

			fi

			# NOTE: We need history record written before save, to get it into the saved file
			# But what if the write fails, then just remove the last history entry
			num_entries=${#kv_store[@]}
			write_global_history "written to '$data_file' ($num_entries entries)"

			#echo -e $'\e[95mWrite Vault to Disk\e[0m'
			# Combine all key-value pairs into a single string using actual newlines

			# Serialize kv_store to save it to the file further down
			combined_data=$(declare -p kv_store)

			# This approach uses base64, but if we serialze the data as above, we wont need base64
			#			combined_data=""
			#			for k in "${!kv_store[@]}"; do
			#				# Append the key as-is
			#				combined_data+="$k"$'\n'
			#
			#				# Base64-encode the value and append it
			#				encoded_value=$(echo -n "${kv_store[$k]}" | base64 -w 0)
			#				combined_data+="$encoded_value"$'\n'
			#			done

			# Encrypt the combined string
			#if __custom_encrypt_data exist in kv store, eval its value and call that function for encryption
			# In case we have custom encryption function, we need to pass the data to it
			if [[ -n "${kv_store["__ced"]}" ]]; then
				# Evaluate the function definition
				eval "${kv_store["__ced"]}"
				# Check if the function exists before calling it
				if declare -f custom_encrypt_data >/dev/null; then
					# Call the custom function with arguments
					encrypted_data=$(custom_encrypt_data "$combined_data" "$password" "$iterations")
				else
					last_confirmation="Custom encrypt function not found."
					continue

				fi
			else
				# Fallback to standard encryption
				encrypted_data=$(encrypt_data "$combined_data" "$password" "$iterations")
			fi

			# If remote file, we can save it back if we have overridden the write function
			# It is overridden by defining code in key __write
			bytes_written=0

			#clone_kv_store
			#clear_kv_store_of_meta_keys

			#if has custom decrypt functoin get its value and base encode it
			if [[ -n "${kv_store["__cdd"]}" ]]; then
				decrypt_func_in_base64_format=$(echo -n "${kv_store["__cdd"]}" | base64 -w 0)
			else
				decrypt_func_in_base64_format=""
			fi

			if [[ $data_file_is_remote -eq 1 ]]; then

				# If we passed allow_edit and have come here, the __write must exist
				if key_exists_in_kv_store "__write"; then
					# User has defined function knowing how to write back to the remote storage
					kv_store["__data_file_path"]="$data_file"
					kv_store["__data_file_name"]=$(basename $data_file)
					#if custom_crypto_version exist in kv store,
					if [[ -n "${kv_store["__ccv"]}" ]]; then
						generated_metadata=$(generate_metadata "$encrypted_data" "$iterations" "$decrypt_func_in_base64_format" "${kv_store["__ccv"]}")
					else
						generated_metadata=$(generate_metadata "$encrypted_data" "$iterations" "$decrypt_func_in_base64_format")
					fi
					bytes_written=$(echo -n "$generated_metadata" | wc -c)
					kv_store["__data_file_content"]="$generated_metadata"
					# NOTE: We do not check for return state, like what did the eval return... we just assume it succeeded and confirm as if
					execute_key "__write"
					eval_exit_status=$?
					unset kv_store["__data_file_path"]
					unset kv_store["__data_file_name"]
					unset kv_store["__data_file_content"]
					if [[ $eval_exit_status -ne 0 ]]; then
						last_confirmation="Error: Writing back to remote storage failed."
						continue
					fi
				else
					echo "Key '__write' does not exist in kv_store."
					last_confirmation="Error: No __write function defined for remote storage."
					# NOTE: See note above
					unwrite_global_history
					continue
				fi

			else
				if [[ -n "${kv_store["__ccv"]}" ]]; then
					generate_metadata "$encrypted_data" "$iterations" "$decrypt_func_in_base64_format" "${kv_store["__ccv"]}" >"$data_file"
				else
					generate_metadata "$encrypted_data" "$iterations" "$decrypt_func_in_base64_format" >"$data_file"
				fi

			fi

			#restore_kv_store

			unsaved_changes=0
			clear_recent_global_history
			last_confirmation=$'\e[92mData saved successfully.\e[0m'

			;;
		q)
			if [[ $unsaved_changes -eq 1 ]]; then
				echo -e "\e[93m⚠️ You have unwritten changes.\e[0m"

				print_recent_global_history
				echo -ne "\e[96mAre you sure you want to exit without saving? (y/N): \e[0m"
				read -n 1 -s response
				echo -n "$response"
				echo
				case "$response" in
				[yY][eE][sS] | [yY])
					echo -e "\e[93mExiting without saving...\e[0m"
					exit 1
					;;
				*)
					last_confirmation="Continuing..."
					;;
				esac
			else
				echo -e "\e[92mExiting...\e[0m"
				exit 0
			fi
			;;

		i)
			echo -e $'\e[95mChange Iterations\e[0m'

			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi
			# Change iterations
			read -rp $'\e[96mEnter new iteration count: \e[0m' new_iterations
			if [[ "$new_iterations" =~ ^[0-9]+$ ]] && [[ "$new_iterations" -gt 0 ]]; then

				write_global_history "iterations changed from $iterations to $new_iterations"
				iterations="$new_iterations"
				calculate_decryption_time_for_given_iter "$iterations"
				unsaved_changes=1
				last_confirmation=$'\e[92mIterations updated to '"$iterations"$'.\e[0m '
			else
				last_confirmation="Error: Iteration count must be a positive integer."
			fi
			;;
		p)
			echo -e $'\e[95mChange Password\e[0m'
			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi

			# Change password
			read -rsp $'\e[91mEnter new password: \e[0m' new_password
			echo
			read -rsp $'\e[91mConfirm new password: \e[0m' confirm_password
			echo
			if [[ "$new_password" == "$confirm_password" ]]; then
				write_global_history "password changed"
				password="$new_password"
				unsaved_changes=1
				last_confirmation=$'\e[92mPassword updated successfully.\e[0m'
			else
				last_confirmation="Error: Passwords do not match."
			fi
			;;
		g)
			echo -e $'\e[95mGenerate Password and Set Key\e[0m'

			if ! allow_edit "$data_file" "$data_file_is_remote"; then
				last_confirmation="Disabled: No edit allowed as file is remote and no support to save it back exists."
				continue
			fi
			# Prompt for key
			if ! is_marked_key_mode_active; then
				read -rp $'\e[96mEnter key name: \e[0m' key
			else
				key="$(marked_key_selected)"

			fi

			# Validate the key
			if [[ -z "$key" ]]; then
				last_confirmation="Error: Key cannot be empty."
				continue
			elif [[ ! "$key" =~ ^[a-zA-Z0-9:._-]+$ ]]; then
				last_confirmation="Error: Key contains illegal characters. Only letters, numbers, dots, dashes, colon, and underscores are allowed."
				continue
			fi

			# Prompt for the desired password length
			read -rp $'\e[93mEnter desired password length (default: 128): \e[0m' length

			# Set default length if not provided
			if [[ -z "$length" ]]; then
				length=128
			elif [[ ! "$length" =~ ^[0-9]+$ ]] || [[ "$length" -lt 1 ]]; then
				last_confirmation="Error: Password length must be a positive integer."
				continue
			fi

			# Generate the password
			generated_password=$(generate_password "$length")

			if key_exists_in_kv_store "$key"; then
				add_history_entry "$key"
			fi

			# Store the generated password as the value for the key
			kv_store["$key"]="$generated_password"

			write_global_history "$key" "random sequence generated ($length bytes)"
			unsaved_changes=1
			last_confirmation=$'\e[92mGenerated password of length \e[93m'"$length"$'\e[92m and set for key \e[93m'"$key"$'\e[92m.\e[0m'
			;;
		x)
			echo -e $'\e[95mExecute Key Content\e[0m'
			if ! is_marked_key_mode_active; then
				read -rp $'\e[96mEnter key to execute: \e[0m' key
			else
				key="$(marked_key_selected)"

			fi
			execute_key "$key"
			;;
			# Updated case option X for listing and executing Bash scripts
		X) # Option to list and execute keys starting with #!/bin/bash
			echo -e $'\e[95mList Keys with Bash Scripts\e[0m'

			# Call the function to populate matching_keys with valid keys
			get_matching_keys matching_keys '^#!/bin/bash'

			# If no matching keys found, display a message and exit this mode
			if [[ ${#matching_keys[@]} -eq 0 ]]; then
				echo -e "\e[91mNo keys with Bash scripts found.\e[0m"
				continue
			fi

			echo
			# List the matching keys with their indices, names, and comments
			for i in "${!matching_keys[@]}"; do
				print_script_with_comments "$((i + 1))" "${matching_keys[$i]}"
			done
			echo
			# Prompt the user to select a key by number
			echo -ne $'\e[96mEnter the number of the key to execute (or press Enter to cancel): \e[0m'
			read -r selected_number

			# If input is empty, cancel the operation
			if [[ -z "$selected_number" ]]; then
				echo -e "\e[93mCancelled.\e[0m"
				continue
			fi

			# Validate the input as a number within range
			if [[ "$selected_number" =~ ^[0-9]+$ ]] && ((selected_number > 0 && selected_number <= ${#matching_keys[@]})); then
				selected_key="${matching_keys[$((selected_number - 1))]}"
				echo -e "\e[92mExecuting key: \e[0m$selected_key"
				execute_key "$selected_key"
			else
				echo -e "\e[91mInvalid selection. Please try again.\e[0m"
			fi
			;;

		V)
			echo -e $'\e[95mView Key Content\e[0m'

			# Prompt for the key to view if no marked key is set
			if ! is_marked_key_mode_active; then
				read -rp $'\e[96mEnter key to view: \e[0m' key
			else
				key="$(marked_key_selected)"
			fi

			# Validate the key
			if [[ -z "$key" ]]; then
				echo -e "No key entered. Operation cancelled."
				continue
			elif [[ -v "${kv_store[$key]}" ]]; then
				echo -e "Error: Key '$key' not found."
				continue
			fi

			# Calculate the underline length based on the visible title length
			static_title="Viewing content for key: "
			visible_length=$((${#static_title} + ${#key}))
			underline=$(printf '=%.0s' $(seq 1 $visible_length))

			# Display the title, underline, and content, then pipe to less
			{
				echo -e "$static_title\e[93m$key\e[0m"
				echo -e "\e[93m$underline\e[0m"
				echo -e "${kv_store[$key]}"
			} | less -R
			;;

		b)
			echo -e $'\e[95mToggle Base64 Encode/Decode\e[0m'

			if ! is_marked_key_mode_active; then
				# Prompt for the key
				read -rp $'\e[96mEnter key to toggle base64 for: \e[0m' key
			else
				key="$(marked_key_selected)"
			fi
			# Check if the key exists
			if [[ -z "$key" ]]; then
				last_confirmation="Error: Key cannot be empty."
				continue
			elif [[ -v "${kv_store[$key]}" ]]; then
				last_confirmation="Error: Key '$key' does not exist."
				continue
			fi

			# Get the current value of the key
			current_value="${kv_store[$key]}"

			# Attempt to decode the value
			decoded_value=$(echo -n "$current_value" | base64 -d 2>/dev/null)
			if [[ $? -eq 0 ]]; then
				add_history_entry "$key"
				# Decoding succeeded, update the key with decoded value
				kv_store["$key"]="$decoded_value"
				write_global_history "$key" "base64 decoded ($(echo -n "$decoded_value" | wc -c) bytes)"
				last_confirmation=$'\e[92mKey \''"$key"$'\' value decoded successfully.\e[0m'
			else
				add_history_entry "$key"
				# Decoding failed, encode the value instead
				encoded_value=$(echo -n "$current_value" | base64 -w 0)
				kv_store["$key"]="$encoded_value"
				write_global_history "$key" "base64 encoded ($(echo -n "$encoded_value" | wc -c) bytes)"
				last_confirmation=$'\e[92mKey \''"$key"$'\' value encoded successfully.\e[0m'
			fi

			unsaved_changes=1
			;;
		*)
			last_confirmation="Unknown command."
			;;

		esac
	done
}

main "$@"
